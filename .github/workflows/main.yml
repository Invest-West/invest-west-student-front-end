name: ChatGPT Auto Fix React Issue

on:
  workflow_dispatch:
    inputs:
      issue_description:
        description: "We want to make our projects viewable to visitors who are not logged in. Can you help with this? The pages are called groupViewOffer & nonGroupViewOffer."
        required: true
        type: string

jobs:
  fix_issue:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout front-end repository
      - name: Checkout front-end repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.PAT_TOKEN }}  # Use PAT_TOKEN with push permissions
          persist-credentials: false

      # Step 2: Checkout back-end repository into 'backend' directory
      - name: Checkout back-end repository
        uses: actions/checkout@v3
        with:
          repository: Invest-West/invest-west-student-back-end
          path: backend
          token: ${{ secrets.PAT_TOKEN }}
          persist-credentials: false

      # Step 3: Set up Git to use PAT
      - name: Configure Git to use PAT
        run: |
          git remote set-url origin https://x-access-token:${{ secrets.PAT_TOKEN }}@github.com/${{ github.repository }}
          git config --global user.email "jserpis@hotmail.co.uk"
          git config --global user.name "Styrle"

      # Step 4: Create or switch to the predefined branch
      - name: Create or switch to the predefined branch
        id: create_branch
        run: |
          branch_name="ai-fixes"
          git fetch origin $branch_name || true
          if git rev-parse --verify origin/$branch_name; then
            echo "Branch $branch_name exists. Checking it out."
            git checkout $branch_name
          else
            echo "Branch $branch_name does not exist. Creating from development."
            git checkout development
            git checkout -b $branch_name
          fi
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT

      # Step 5: Identify all code files
      - name: Identify all code files
        id: find_files
        run: |
          # Find files in the front-end 'src' directory
          find ./src -type f \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" \) > frontend_files.txt
          # Find files in the back-end directory
          find ./backend -type f \( -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" \) > backend_files.txt
          # Combine file lists
          cat frontend_files.txt backend_files.txt > all_files.txt
          # Output file paths
          echo "file_list=all_files.txt" >> $GITHUB_OUTPUT

      # Step 6: Use OpenAI to identify relevant files
      - name: Identify relevant files with OpenAI
        id: identify_relevant_files
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI }}
        run: |
          issue_description="${{ github.event.inputs.issue_description }}"
          file_list="all_files.txt"
          # Read all file paths into an array
          mapfile -t files < "$file_list"
          # Prepare the prompt
          file_paths=$(printf "%s\n" "${files[@]}")
          user_message="Based on the following issue description, please list the file paths that need to be modified to fix the issue. Provide the list in a JSON array format.\n\nIssue Description:\n$issue_description\n\nAvailable File Paths:\n$file_paths"
          # Build JSON payload using jq
          json_payload=$(jq -n \
            --arg model "gpt-4" \
            --arg content "$user_message" \
            --argjson max_tokens 3000 \
            '{model: $model, messages: [{role: "user", content: $content}], max_tokens: $max_tokens}')
          # Call OpenAI API
          response=$(echo "$json_payload" | curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @-)
          # Check for errors in the response
          if echo "$response" | jq -e '.error' >/dev/null; then
            error_message=$(echo "$response" | jq -r '.error.message')
            echo "Error from OpenAI API: $error_message"
            exit 1
          fi
          # Extract the list of relevant files
          relevant_files=$(echo "$response" | jq -r '.choices[0].message.content' | jq '.')
          # Save the list to a file
          echo "$relevant_files" > relevant_files.json
          echo "Relevant files identified:"
          echo "$relevant_files"
          # Output the list of relevant files
          echo "relevant_files=$PWD/relevant_files.json" >> $GITHUB_OUTPUT

      # Step 7: Call OpenAI to suggest fixes for relevant files
      - name: Call OpenAI to suggest fixes
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI }}
        run: |
          set -e
          issue_description="${{ github.event.inputs.issue_description }}"
          relevant_files="${{ steps.identify_relevant_files.outputs.relevant_files }}"
          files=$(jq -r '.[]' "$relevant_files")
          for file in $files; do
            if [[ -f "$file" ]]; then
              echo "Processing $file"
              # Create a backup of the original file
              cp "$file" "$file.bak"
              # Initialize variables
              total_lines=$(wc -l < "$file")
              start_line=1
              chunk_size=200
              temp_file=$(mktemp)
              # Process the file in chunks of 200 lines
              while [[ $start_line -le $total_lines ]]; do
                end_line=$((start_line + chunk_size - 1))
                if [[ $end_line -gt $total_lines ]]; then
                  end_line=$total_lines
                fi
                echo "Processing lines $start_line to $end_line of $file"
                # Extract the chunk
                sed -n "${start_line},${end_line}p" "$file" > "$temp_file"
                # Remove comments to reduce token count
                sed -i '/^\s*\/\//d;/^\s*\/\*/,/\*\//d' "$temp_file"
                # Prepare the user message
                user_message="Here is the issue: $issue_description\n\nPlease provide the necessary code changes to fix the issue in the following code snippet. Provide the changes in unified diff format (diff -u) that can be applied directly.\n\nCode Snippet:\n$(cat "$temp_file")"
                # Build JSON payload
                json_payload=$(jq -n \
                  --arg model "gpt-4" \
                  --arg content "$user_message" \
                  --argjson max_tokens 1500 \
                  '{model: $model, messages: [{role: "user", content: $content}], max_tokens: $max_tokens}')
                # Call OpenAI API
                response=$(echo "$json_payload" | curl -s https://api.openai.com/v1/chat/completions \
                  -H "Authorization: Bearer $OPENAI_API_KEY" \
                  -H "Content-Type: application/json" \
                  -d @-)
                # Check for errors
                if echo "$response" | jq -e '.error' >/dev/null; then
                  error_message=$(echo "$response" | jq -r '.error.message')
                  echo "Error from OpenAI API: $error_message"
                  exit 1
                fi
                # Extract the suggestion
                fix_patch=$(echo "$response" | jq -r '.choices[0].message.content')
                # Apply the patch if it's in correct format
                if [[ "$fix_patch" =~ ^--- ]]; then
                  echo "Applying patch to $file (lines $start_line to $end_line)"
                  # Write the patch to a temporary file
                  patch_file=$(mktemp)
                  echo "$fix_patch" > "$patch_file"
                  # Adjust the file paths in the patch
                  sed -i "s|^---.*|--- $file|; s|^\+\+\+.*|+++ $file|" "$patch_file"
                  # Apply the patch
                  if patch "$file" "$patch_file"; then
                    echo "Patch applied successfully."
                  else
                    echo "Failed to apply patch to $file"
                  fi
                  rm -f "$patch_file"
                else
                  echo "No valid patch provided for $file (lines $start_line to $end_line)"
                fi
                # Move to the next chunk
                start_line=$((end_line + 1))
              done
              rm -f "$temp_file"
            else
              echo "File $file does not exist"
            fi
          done

      # Step 8: Show modified files
      - name: Show modified files
        run: |
          echo "Modified files:"
          git status --short

      # Step 9: Commit the changes
      - name: Commit the changes
        run: |
          git add .
          git commit -m "Auto fix for issue: ${{ github.event.inputs.issue_description }}" || echo "No changes to commit"

      # Step 10: Push the changes
      - name: Push the changes
        run: |
          git push -u origin "${{ steps.create_branch.outputs.branch_name }}"
